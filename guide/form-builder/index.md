# About

Generate html forms bound to Validation or Jelly objects, render errors and repopulate forms

## Usage

First you will have to create a class object with the appropriate data - forms without any association with validation or ORM can be created with the Form_Builder class

	$form = Form_Builder::factory($_POST);

After that you can use your class to generate html input tags. The templates and the tags themselves are generated by a Form_Renderer class which has the task of the actual creation of the HTML.
The default renderer can handle basic HTML inputs like input, textarea and select. You can extend / create your own Renderer if you need more functionality. 

To set a new renderer:

	$form->renderer("My_Form_Renderer");

You can also set a "prefix" for the form inputs. It will use it for each input name, so you can create nested forms. for example 
	
	$form->prefix("nested_form[%s]");
	// OR
	$form->prefix("nested_form[child_form][%s]");

The factory method handles Array, Validation object and Jelly_Model

	$form = Form_Builder::factory('jelly', $jelly_model, $_POST); //Creates Form_Jelly_Builder
	$form = Form_Builder::factory('validation', $validation_object); //Creates Form_Validation_Builder
	$form = Form_Builder::factory($array); //Creates Form_Builder

## Form rows and fields

A row is a html snipped with the input field itself along with a label, errors and some css classes.
Some examples:

	$form->row("input", "username");
	$form->row("input", "username", array("label" => "User Name"));
	$form->row("select", "accept", array("choices" => array("yes", "no"));

	$form->field("textarea", "text", null, array("rows" => 50));

The rows method has those arguments:

	function row( $render, $name, $options, $attributes );

- __$render__ is the name of the render method to call on the Renderer class - possible values are input, hidden, checkbox, select, textarea, password, date, file. Form_Jelly_Renderer also has image
- __$name__ is the name of the field. This will be used to retrieve the value of the input.
- __$options__ an array of options that modify the behaviour
	- _template_ add a custom template
	- _label_ set the label text, human version of the $name is used as a default
	- _errors_ the errors for the field (Validation or Jelly) defaults with the errors for this field from the validaiton
	-	_object_ (Validaiton or Jelly) defaults to the current object
- __$attributes__ html attributes for the input. id and name are prefilled by default. Jelly also sets HTML5 validation based on the database field

	function field( $render, $name, $options, $attributes );

Uses the same arguments but only returns the field without the template - you can construct one yourself

	<div>
		<?php echo $form->label("username") ?>
		<?php echo $form->field("input", "username") ?>
		<?php if ($form->errors("username")): ?>
			<small><?php echo $form->errors("username") ?></small>
		<?php endif ?>
	</div>

## Validaiton form

You can use Kohana's built in validation object to create forms independant from ORMs. For example:

	//Controller
	$form = Form_Builder::factory(
		'validation',
		Validation::factory($_POST)
			->rule("username", "not_empty")
			->rule("password", "not_empty")
	);

	$form->error_file("path/to/errors");

	if($_POST AND $form->check())
	{
		echo "Correct!";
	}

	//View
	<?php echo Form::open("login") ?>
		<?php echo $form->row("input", "username") ?>
		<?php echo $form->row("password", "password") ?>
	<?php echo Form::close(); ?>

## Jelly form

	//Controller
	$form = Form_Builder::factory('jelly', Jelly::factory("user", $id), Arr::merge($_POST, $_FILES));

	$form->error_file("path/to/errors");

	if($_POST AND $form->check())
	{
		$form->save();
		echo "Correct!";
	}

	//View
	<?php echo Form::open("login") ?>
		<?php echo $form->row("input", "username") ?>
		<?php echo $form->row("password", "password") ?>
	<?php echo Form::close(); ?>



